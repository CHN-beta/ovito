<?xml version="1.0" encoding="utf-8"?>
<section xsi:schemaLocation="http://docbook.org/ns/docbook http://docbook.org/xml/5.0/xsd/docbook.xsd"
         xml:id="atomviz.overview" xmlns="http://docbook.org/ns/docbook"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:xs="http://www.w3.org/2001/XMLSchema"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title>OVITO basics</title>

  <para>This section of the manual introduces the basic concepts of OVITO that
  you need to work effectively with the software.</para>

  <section xml:id="atomviz.overview.data_model">
    <title>Data model</title>

    <para>OVITO uses an object-oriented data model to store atomistic
    datasets. The basic object is the so-called <firstterm>Atoms
    Object</firstterm>, which encompasses a single snapshot of an atomistic
    system. It includes the simulation cell geometry and the per-atom data.
    The latter is subdivided into so-called <firstterm>data
    channels</firstterm>. A data channel is basically a data array, with one
    entry per atom, that stores one property for all atoms. These per-atom
    values can be either scalars or vectors or something more complex (e.g.
    tensors). OVITO knows a number of pre-defined types of data channels that
    store commonly used properties. One example is the mendatory <link
    linkend="atomviz.data_channels.position">Position</link> data channel,
    which stores the atomic coordinates in a 3-component vector per atom.
    Another important data channel is the <link
    linkend="atomviz.data_channels.atomtype">Atom Type</link> data channel,
    which stores the type (i.e. chemical species) of each atom as an integer
    number.</para>

    <para>In addition to the per-atom data, some data channels store global
    parameters and settings that are specific to the data channel type. For
    example, the <link linkend="atomviz.data_channels.atomtype">Atom
    Type</link> data channel also stores the names, colors, and radii of each
    atomic species. OVITO uses this information to display atoms of each atom
    type differently. Such global settings are documented for each standard
    channel in the <link linkend="atomviz.data_channels">data channel
    reference section</link> of this manual.</para>

    <para>OVITO allows the user to define new custom data channels. This can
    either happen during import of a dataset file that contains extra data
    columns, which are not mapped to one of OVITO's standard channels. Or it
    can happen within the processing pipeline of OVITO, when the user inserts
    a modifier that can generate a non-standard data channel, for example the
    <link linkend="atomviz.modifiers.add_expression_channel">Compute
    Channel</link> modifier.</para>

    <para>Another term that you'll encounter in this manual and when using the
    software is <firstterm>scene</firstterm>. A scene refers to the parameters
    and settings that you edit in OVITO. Roughly speaking, it is equivalent to
    what is usually called a document in other programs. The scene includes
    the data source, all modifiers and their settings in the processing
    pipeline, and the viewport configuration. You can save the complete scene
    to a file, like in other editing programs, and load it again at a later
    time. By default the simulation dataset imported into OVITO is not stored
    in the scene file. OVITO rather stores the path to the original simulation
    file to save space. However, you can select to store the atoms in the
    scene file, making it easier to transfer the entire scene including the
    simulation data to a different computer for example.</para>
  </section>

  <section xml:id="atomviz.overview.processing_model">
    <title>Processing model</title>

    <para>When importing a simulation dataset file into OVITO, it is
    internally represented by an <firstterm>Atoms Object</firstterm> as
    introduced in the previous section. OVITO interprets the information
    stored in the data channels of the <firstterm>Atoms Object</firstterm> to
    display it in the viewports. This data, however, is not static. You can
    define a sequence of operations, which are applied to the data before it
    is rendered to the screen by OVITO. These operations are called
    <firstterm>modifiers</firstterm> in OVITO and are the basic building
    blocks, which you put together to achieve a given task or goal.</para>

    <figure>
      <title>Illustration of the modifier pipeline concept</title>

      <screenshot>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/modifiers/pipeline_example.png"
                       format="png" xml:base="../"/>
          </imageobject>
        </mediaobject>
      </screenshot>
    </figure>

    <para>The sequence of modifiers put together by the user is called the
    <firstterm>processing pipeline</firstterm>. First, an <firstterm>Atoms
    Object</firstterm> is generated from the input data read from the external
    file, then it is fed into the processing pipeline, undergoes
    transformations as the selected modifiers are applied, and is finally
    handed over to the display engine, which generates the picture seen in the
    viewports. In fact, while working with OVITO, you spend most of the time
    adding modifiers to the pipeline and setting their parameters. This manual
    contains a list of <link linkend="atomviz.modifiers">available modifier
    types</link>.</para>

    <para>The described modifier concept gives OVITO its great flexibility
    because, in contrast to a classical workflow, the data is not changed
    permanently by the modifiers. Instead, you can go back and change a
    modifier's parameters whenever needed, or disable some modifers, and OVITO
    will immediately re-evaluate all operations and update the results. Of
    course, you can also replace the dataset fed into the processing pipeline
    easily and pick a different input file. This is ideal for batch processing
    of a large number of simulation snapshots, for example. The same applies
    to a time sequence of simulation snapshots: All modifier operations that
    you insert into the processing pipeline are automatically applied in
    realtime to every frame of the simulation as you playback the
    animation.</para>
  </section>
</section>
