<?xml version="1.0" encoding="utf-8"?>
<section version="5.0"
         xsi:schemaLocation="http://docbook.org/ns/docbook http://docbook.org/xml/5.0/xsd/docbook.xsd"
         xml:id="usage.scripting" xmlns="http://docbook.org/ns/docbook"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:xs="http://www.w3.org/2001/XMLSchema"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title>Scripting</title>

  <simplesect>
  <title>Introduction</title>
    <para>
       OVITO provides a scripting interface that allows users to automate tasks or batch-process
       a large number of input files. The program's built-in script interpreter is based on the 
       <link xlink:href="http://www.ecma-international.org/publications/standards/Ecma-262.htm">ECMAScript language</link>,
       which forms also the basis for the popular <link xlink:href="http://en.wikipedia.org/wiki/JavaScript">JavaScript language</link> used in web browsers. 
       If you are not familiar with JavaScript or the ECMAScript language, you can find several tutorials and books online that cover this subject. 
    </para>
    <para>
       OVITO's scripting interface enables programmatic access to various functions of the program such as 
       importing and exporting data, adding modifiers, and rendering images or movies.
    </para>
  </simplesect>
  
  <simplesect xml:id="usage.scripting.running_scripts">
  <title>Running scripts</title>
    <para>
       OVITO scripts are normal text files that can be created with any text editor. To execute a script, start OVITO from the command line as follows. Optional arguments are in brackets:
       <screen><command>   ovito  [--nogui] --script myscript.js [datafile]</command></screen>
       This will run the script file <command>myscript.js</command> after program startup. The optional
       argument <command>[datafile]</command> specifies the path or URL of a simulation file to be imported
       before the script is executed. You can also load an OVITO scene file to restore an old program state
       including modifiers etc.
     </para>
     <para> 
       The optional <command>--nogui</command> option switches to a non-graphical batch
       mode and OVITO quits after the script has finished executing. In this mode, OVITO's normal user interface is not shown, 
       which is useful when running OVITO scripts on remote machines that don't have a graphics terminal. 
       Note to Windows users: On this platform you won't see any window or console output when using this command line switch. Even though the script is executed in the background, 
       this makes it difficult to tell whether execution was successful or not. On Linux and Mac OS, error messages and 
       text output generated by the script are redirected to the terminal.
    </para>
    
    <para>
       You can find more documentation on OVITO's scripting functions in the <link linkend="scripting">reference section</link> of this manual.
    </para>
    
  </simplesect>
  
  <simplesect>
  <title>Script example</title>
    <para>
      The following example program demonstrates how various functions of OVITO can be accessed from a script:
      <programlisting language="javascript">
<![CDATA[// Query program version.
print("This is Ovito " + ovito.version)

// Import a data file.
node = load("../data/NanocrystallinePd.dump.gz")

// Block execution of the script until the scene is ready, that is, until 
// the input file has been completely loaded.
// This is an optional step, but it ensures that the modifier we are going to create 
// has access to the input data at the time it is inserted into the modification pipeline.
// This allows the Color Coding modifier to automatically adjust its interval to the range of 
// values present in the input data.
wait()

// Apply a modifier to the dataset.
node.applyModifier(new ColorCodingModifier({ 
	sourceProperty : "Potential Energy",
	colorGradient  : new ColorCodingHotGradient()
}))

// Set up view, looking along the [2,3,-3] vector.
activeViewport.perspective(Point(-100, -150, 150), Vector(2, 3, -3), 60.0 * Math.PI/180.0)

// Render a picture of the dataset.
activeViewport.render({
	filename    : "rendering.png",
	imageWidth  : 120,
	imageHeight : 120
})

// Apply two more modifiers to delete some particles.
node.applyModifier(new SelectExpressionModifier({ expression : "PotentialEnergy < -3.9" }))
node.applyModifier(new DeleteParticlesModifier())

// Print the modification pipeline of the selected node to the console.
print("Current modification pipeline:")
for(var i = 0; i < node.modifiers.length; i++)
	print("  " + node.modifiers[i])  
	
// Perform some analysis.
cna = new CommonNeighborAnalysisModifier({ cutoff : 3.2, adaptiveMode : false })
node.applyModifier(cna)

// Wait until computation has been completed.
wait()

// Read out analysis results.
print("Number of FCC atoms: " + cna.structureCounts[CommonNeighborAnalysisModifier.FCC])

// Write processed atoms back to an output file.
save("exporteddata.dump", LAMMPSDumpExporter, 
	{ columnMapping: ["Position.X", "Position.Y", "Position.Z", "Structure Type"] })]]>
      </programlisting>
    </para>
  </simplesect>
  
</section>
