<?xml version="1.0" encoding="utf-8"?>
<section version="5.0"
         xsi:schemaLocation="http://docbook.org/ns/docbook http://docbook.org/xml/5.0/xsd/docbook.xsd"
         xml:id="scripting.scene_objects" xmlns="http://docbook.org/ns/docbook"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:xs="http://www.w3.org/2001/XMLSchema"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title>Working with modifiers</title>

  <simplesect xml:id="scripting.scene_objects.apply_modifier">
  	<title>Applying new modifiers</title> 
    <para>
  	    The <link linkend="scripting.input_output.load"><code>load()</code></link> script function returns a reference to the imported object, which consists of
  	    the external data source and the modification pipeline, which processes the imported data before it is displayed on screen. You can populate the
  	    modification pipeline with modifiers from a script as follows:
  	    <informalexample><programlisting language="javascript"><![CDATA[
// Load an external data file. 
// This creates a new object in OVITO with an attached modification pipeline.
obj = load("simulation.dump")

// Insert two new modifiers using the applyModifier() function:
obj.applyModifier(new SelectExpressionModifier({ expression : "PotentialEnergy < -3.9" }))
obj.applyModifier(new DeleteParticlesModifier())]]>
</programlisting></informalexample>

		The <code>applyModifier()</code> method appends a modifier to the modification pipeline. The new modifier is created using the <code>new</code> keyword
		followed by the modifier type name. Note that we are calling a constructor function here, which is the standard way of creating new objects in JavaScript.
		The following modifier types are available in OVITO:
    </para> 
    <para>
    	<code>AffineTransformationModifier</code>, 
    	<code>AmbientOcclusionModifier</code>, 
    	<code>AssignColorModifier</code>, 
    	<code>AtomicStrainModifier</code>, 
    	<code>BondAngleAnalysisModifier</code>, 
    	<code>CalculateDisplacementsModifier</code>, 
    	<code>CentroSymmetryModifier</code>, 
    	<code>ClearSelectionModifier</code>, 
    	<code>ClusterAnalysisModifier</code>, 
    	<code>ColorCodingGradient</code>, 
    	<code>CommonNeighborAnalysisModifier</code>, 
    	<code>CoordinationNumberModifier</code>, 
    	<code>CreateBondsModifier</code>,
    	<code>CreateExpressionPropertyModifier</code>, 
    	<code>DeleteParticlesModifier</code>, 
    	<code>FreezeSelectionModifier</code>, 
    	<code>HistogramModifier</code>, 
    	<code>InvertSelectionModifier</code>, 
    	<code>ManualSelectionModifier</code>,
    	<code>SelectExpressionModifier</code>, 
    	<code>SelectParticleTypeModifier</code>, 
    	<code>ShowPeriodicImagesModifier</code>, 
    	<code>SliceModifier</code>, 
    	<code>WrapPeriodicImagesModifier</code>
    </para> 
    <para>
        A modifier's constructor function accepts an optional object literal, which is used to initialize its parameters as demonstrated in the previous example. 
        Alternatively, you can set individual parameters after having created the modifier (It doesn't matter if you do that before or after inserting the modifier into the pipeline):
  	    <informalexample><programlisting language="javascript"><![CDATA[
modifier = new SelectExpressionModifier()
obj.applyModifier(modifier)
modifier.expression = "PotentialEnergy < -3.9"]]>
</programlisting></informalexample>
    </para> 
  </simplesect>

  <simplesect xml:id="scripting.scene_objects.modifiers">
  	<title>Accessing the modification pipeline</title> 
    <para>
       Each scene object has a property <code>modifiers</code>, which is the list of modifiers in the current pipeline. This
       allows you to access existing modifiers, which have not been added to the pipeline by the script:
  	    <informalexample><programlisting language="javascript"><![CDATA[
// Print the list of modifiers in the current pipeline:
for(var i = 0; i < obj.modifiers.length; i++)
    print(obj.modifiers[i])
]]>
</programlisting></informalexample>
    </para>
  </simplesect>

  <simplesect xml:id="scripting.scene_objects.wait">
  	<title>The <code>wait()</code> function</title> 
    <para>
       OVITO uses an asynchronous (and multi-threaded) evaluation model to compute the results of the modification pipeline. This allows the user to continue working
       with the program while it is still computing the effect of an analysis modifier that takes a long time to evaluate. 
       Not all modifiers take part in this asynchronous evaluation model: 
       Simple modifiers that are inexpensive to evaluate, like the <link linkend="particles.modifiers.select_particle_type">Select particle type modifier</link>, 
       are processed immediately. More expensive analysis modifier such as the <link linkend="particles.modifiers.coordination_analysis">Coordination analysis modifier</link>,
       which potentially take a long time to compute for large systems, are evaluated asynchronously.
    </para>
    <para>
       That means, if you want to access the results of such a modifier from your script, you have to wait until OVITO has finished computing it. This can be achieved with the 
       <code>wait()</code> script function. For example:
  	    <informalexample><programlisting language="javascript"><![CDATA[
// Insert an analysis modifier, which takes long to compute:
modifier = new CommonNeighborAnalysisModifier({ cutoff : 3.2, adaptiveMode : false })
object.applyModifier(modifier)

// Wait until calculation has been completed. 
wait()

// Now it's safe to read out the modifier's results:
numFCC = modifier.structureCounts[CommonNeighborAnalysisModifier.FCC]
print("Number of FCC atoms: " + numFCC)]]>
</programlisting></informalexample>
In this example, we read out the <code>structureCounts</code> array of the CNA modifier, which contains the number of particles found for each known structure type.
If we had accessed this array without calling <code>wait()</code> first, it would contain invalid or old data since the modifier would still be in the process of performing 
the analysis.
    </para>  
    <para>
       Calling the <code>wait()</code> function is only necessary when directly accessing output properties of analysis modifiers. It is <emphasis>not</emphasis> necessary
       when <link linkend="scripting.rendering">rendering a picture</link> of the dataset or when exporting the processed particles to an output file using <link linkend="scripting.input_output.save"><code>save()</code></link>. 
       In these cases, OVITO will implicitly call the <code>wait()</code> function to make sure the modification pipeline has been fully evaluated.
    </para>
    <para>
       Loading a dataset from an external file is also an asynchronous operation, similar to evaluating analysis modifiers. Accordingly, you can also use the 
       <code>wait()</code> function to block script execution until a dataset has been fully loaded and is ready to be fed into the modification pipeline.
       This may be useful in some situations, for instance when inserting the <link linkend="particles.modifiers.slice">Slice modifier</link>. This modifier will automatically
       position the slicing plane in the center of the simulation cell when it is first inserted into the modification pipeline. This automatic initialization only works
       if the simulation cell geometry has already been loaded from the file at the time the modifier is inserted into the pipeline. The following example demonstrates
       how to explicitly synchronize this using the <code>wait()</code> function:
  	    <informalexample><programlisting language="javascript"><![CDATA[
// Start loading a data file (asynchronously):
obj = load("simulation.dump")

// Block script execution until data has been completely loaded and the simulation cell geometry is known.  
wait()

// Now insert the Slice modifier using default parameters, which will position the slicing plane in the center of the simulation cell:
obj.applyModifier(new SliceModifier())]]>
</programlisting></informalexample>
	   Note that using the <code>wait()</code> function would not have been necessary here if we had positioned the slicing plane explicitly from the script and independent
	   from the simulation cell geometry.
    </para>
  </simplesect>
    
</section>
