///////////////////////////////////////////////////////////////////////////////
// 
//  Copyright (2016) Alexander Stukowski
//
//  This file is part of OVITO (Open Visualization Tool).
//
//  OVITO is free software; you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation; either version 2 of the License, or
//  (at your option) any later version.
//
//  OVITO is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
///////////////////////////////////////////////////////////////////////////////

#pragma once


#include <core/Core.h>
#include "PromiseState.h"

#include <QThreadPool>
#include <QMetaObject>

namespace Ovito { OVITO_BEGIN_INLINE_NAMESPACE(Util) OVITO_BEGIN_INLINE_NAMESPACE(Concurrency)

/**
 * \brief Manages the background tasks.
 */
class OVITO_CORE_EXPORT TaskManager : public QObject
{
	Q_OBJECT

private:

	/// Constructor.
	TaskManager(DataSetContainer& owner);

	/// Destructor.
	~TaskManager();

	/// Only DataSetContainer can create a TaskManager.
	friend class DataSetContainer;

public:

	/// Returns the dataset container owning this task manager.
	DataSetContainer& datasetContainer() { return _owner; }

	/// \brief Returns the list of watchers of all currently running tasks.
	///
	/// This method may only be called from the main thread.
	const std::vector<PromiseWatcher*>& runningTasks() const { return _runningTaskStack; }

	/// \brief Executes an asynchronous task in a background thread.
	///
	/// This function is thread-safe. It returns a Future that is fulfilled when the task completed.
	template<class TaskType>
	auto runTaskAsync(const std::shared_ptr<TaskType>& task) {
		OVITO_ASSERT(task);
		QThreadPool::globalInstance()->start(task.get());
		registerTask(task);
		return task->future();
	}

	/// \brief Registers a future's promise with the progress manager, which will display the progress of the background task
	///        in the main window.
	///
	/// This function is thread-safe.
	void registerTask(const FutureBase& future);

	/// \brief Registers a promise with the progress manager, which will display the progress of the background task
	///        in the main window.
	///
	/// This function is thread-safe.
	void registerTask(const PromiseBase& promise);

	/// \brief Registers a promise with the progress manager, which will display the progress of the background task
	///        in the main window.
	///
	/// This function is thread-safe.
	void registerTask(const PromiseStatePtr& sharedState);

	/// Create a new promise for operations that run in the main thread and registers it with this task manager.
	template<typename... R>
	Promise<R...> createSynchronousPromise(bool startedState) {
		using tuple_type = std::tuple<R...>;
		Promise<R...> promise(std::make_shared<PromiseStateWithResultStorage<SynchronousPromiseState, tuple_type>>(
			PromiseState::no_result_init_t(), 
			startedState ? PromiseState::State(PromiseState::Started) : PromiseState::NoState, *this));
		addTaskInternal(promise.sharedState());
		return promise;
	}

	/// \brief Waits for the given task to finish and displays a modal progress dialog
	///        to show the task's progress.
	/// \return False if the task has been cancelled by the user.
	///
	/// This function must be called from the main thread.
	bool waitForTask(const FutureBase& future);

	/// \brief Waits for the given task to finish.
	bool waitForTask(const PromiseStatePtr& sharedState);

	/// \brief Process events from the event queue when the tasks manager has started
	///        a local event loop. Otherwise does nothing and lets the main event loop
	///        do the processing. 
	void processEvents();

	/// \brief This should be called whenever a local event handling loop is entered.
	void startLocalEventHandling();

	/// \brief This should be called whenever a local event handling loop is left.
	void stopLocalEventHandling();

public Q_SLOTS:

	/// Cancels all running tasks.
	void cancelAll();

	/// Cancels all running tasks and waits for them to finish.
	void cancelAllAndWait();

	/// Waits for all running tasks to finish.
	void waitForAll();

Q_SIGNALS:

	/// \brief This signal is generated by the task manager whenever a new task started to run.
	/// The PromiseWatcher can be used to track the task's progress.
	void taskStarted(PromiseWatcher* taskWatcher);

	/// \brief This signal is generated by the task manager whenever a task finished or stopped running.
	void taskFinished(PromiseWatcher* taskWatcher);

private:

	/// \brief Registers a promise with the progress manager.
	Q_INVOKABLE PromiseWatcher* addTaskInternal(const PromiseStatePtr& sharedState);

private Q_SLOTS:

	/// \brief Is called when a task has started to run.
	void taskStartedInternal();

	/// \brief Is called when a task has finished.
	void taskFinishedInternal();

private:

	/// The list of watchers for the active tasks.
	std::vector<PromiseWatcher*> _runningTaskStack;

	/// Indicates that waitForTask() has started a local event loop.
	int _inLocalEventLoop = 0; 

	/// The dataset container owning this task manager.
	DataSetContainer& _owner;

	// Needed by SynchronousPromiseState::createSubOperation():
	friend class SynchronousPromiseState;
};

OVITO_END_INLINE_NAMESPACE
OVITO_END_INLINE_NAMESPACE
}	// End of namespace

Q_DECLARE_METATYPE(Ovito::PromiseStatePtr);


