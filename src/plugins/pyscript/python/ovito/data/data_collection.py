import abc
try:
    # Python 3.x
    import collections.abc as collections
except ImportError:
    # Python 2.x
    import collections

from ..plugins.PyScript import DataObject, CloneHelper

def with_metaclass(meta, *bases):
    """
    Python 2/3 cross-compatibility function for setting a class' metaclass.
    Function from jinja2/_compat.py. License: BSD.
    """
    class metaclass(meta):
        __call__ = type.__call__
        __init__ = type.__init__
        def __new__(cls, name, this_bases, d):
            if this_bases is None:
                return type.__new__(cls, name, (), d)
            return meta(name, bases, d)
    return metaclass('temporary_class', None, {})

class DataCollection(with_metaclass(abc.ABCMeta)):
    """ 
    A :py:class:`!DataCollection` is a generic container that holds together multiple *data objects*, each representing 
    a different facet of a dataset. Data collections are the main entities that are processed by OVITO's
    data pipeline system. Within a data collection, you will typically find a bunch of data objects of different types, 
    which collectively form the dataset:

        * :py:class:`~ovito.data.ParticleProperty` (an array of per-particle values)
        * :py:class:`~ovito.data.SimulationCell` (the cell vectors and boundary conditions)
        * :py:class:`~ovito.data.BondProperty` (an array of per-bond values)
        * :py:class:`~ovito.data.SurfaceMesh` (triangle mesh representing a two-dimensional manifold)
        * :py:class:`~ovito.data.DislocationNetwork` (discrete dislocation lines)
        * ... and more

    Note that all these types derive from the common :py:class:`~ovito.data.DataObject` base class. A :py:class:`!DataCollection` instance comprises two parts:

        1. The :py:attr:`.objects` list, which can hold an arbitrary number of data objects of the types listed above. 
        2. The :py:attr:`.attributes` dictionary, which stores auxialliary data in the form of simple key-value pairs.

    **Specializations**

    Note that the :py:class:`!DataCollection` class is only an abstract base class (an *interface*). That means data collections are 
    always instances of one of the following sub-classes derived from :py:class:`!DataCollection`:

        * :py:class:`~ovito.data.PipelineFlowState` - a transient data collection processed or generated by a data pipeline
        * :py:class:`~ovito.pipeline.FileSource` - a data collection loaded from a file and serving as pipeline input
        * :py:class:`~ovito.pipeline.StaticSource` - a data collection created at runtime and serving as pipeline input

    The :py:class:`!DataCollection` base class provides the base functionality common to all of these specific 
    data collection types, which are used in different contexts. 

    **Data object access**

    The :py:meth:`find` and :py:meth:`find_all` methods allow you to look up data objects in the :py:attr:`.objects` list of a data collection 
    by type. For example, to retrieve the :py:class:`~ovito.data.SimulationCell` from a data collection:

    .. literalinclude:: ../example_snippets/data_collection.py
           :lines: 9-10

    The :py:meth:`find` method yields ``None`` if there is no instance of the given type is in the collection.
    Alternatively, you can use the :py:meth:`.expect` method, which will raise an exception in case the requested object type is not present:

    .. literalinclude:: ../example_snippets/data_collection.py
           :lines: 15-15

    It is possible to programmatically add or remove data objects from the data collection by manipulating the :py:attr:`.objects` list.
    For instance, to populate a new :py:class:`~ovito.pipeline.StaticSource`, which is initially empty, with a :py:class:`~ovito.data.SimulationCell` object:

    .. literalinclude:: ../example_snippets/data_collection.py
           :lines: 20-22

    There are certain conventions regarding the numbers and types of data objects that may be present in a data collection.
    For example, there should never be more than one :py:class:`~ovito.data.SimulationCell` instance within the same data collection.
    In contrast, there may be an arbitrary number of :py:class:`~ovito.data.ParticleProperty` instances in a data collection,
    but they all must have unique names. Furthermore, there must always be one :py:class:`~ovito.data.ParticleProperty` named ``Position``
    in a data collection, or no :py:class:`~ovito.data.ParticleProperty` at all. When manipulating the :py:attr:`.objects` list of a data
    collection directly, it is your responsibility to make sure that these conventions are followed.

    **Particle and bond access**

    To simplify the work with particles and bonds, which are represented by a bunch of :py:class:`~ovito.data.ParticleProperty` or
    :py:class:`~ovito.data.BondProperty` instances, respectively, the :py:class:`!DataCollection` base class provides two special 
    accessor fields. The :py:attr:`.particles` field represents a dictionary-like view of all the :py:class:`~ovito.data.ParticleProperty` data objects that are contained in a data collection. It thus works like a dynamic filter for the :py:attr:`.objects` list and permits named-based access to individual particle properties: 

    .. literalinclude:: ../example_snippets/data_collection.py
           :lines: 26-27

    Similarly, the :py:attr:`.bonds` field is a dictionary-like view of all the :py:class:`~ovito.data.BondProperty` instances in
    a data collection. If you are adding or removing particle or bond properties in a data collection, you should 
    always do so through these accessor fields instead of manipulating the :py:attr:`.objects` list directly.
    This will ensure that certain invariants are always maintained, e.g. the uniqueness of property names and consistent size
    of all property arrays.

    **Attribute access**

    In addition to data objects, which represent complex forms of data, a data collection can contain an arbitrary number of *attributes*, which are simple key-value pairs. The :py:attr:`.attributes` field of the data collection behaves like a Python dictionary and allows you to 
    read, manipulate or newly insert attributes, which are typically numeric values or string values. 

    **Data ownership**
    
    A data object may be part of more than one :py:class:`!DataCollection` at a time, i.e. it may be shared by several data collections. 
    This is because the pipeline system of OVITO uses shallow data copies for performance reasons and to implement efficient data caching. 
    Typically, modifiers manipulate only certain data objects in a collection. For example, the :py:class:`~ovito.modifiers.ColorCodingModifier`
    will selectively modify the values of the ``Color`` particle property but won't touch any of the other objects that
    may be present in the input data collection. These unmodified data objects will simply be passed through to the output data collection
    without creating a new copy of the data. As a consequence of this design, both the input data collection and the 
    output collection of the pipeline may refer to the same data object instances. In this situation, none of the data collections owns the 
    data objects exclusively anymore.

    Thus, in general it is not safe to manipulate the contents of a data object in a data collection, because that could lead to 
    unwanted side effects or corruption of data maintained by the pipeline system:
    
    .. literalinclude:: ../example_snippets/data_collection.py
           :lines: 31-33
    
    Before manipulating the contents of a data object in any way, it is crucial to ensure that no second data collection is referring to the same data. The :py:meth:`.copy_if_needed` method helps you ensure that a data object is exclusive owned by a certain data collection.
    It first checks whether the given object is currently shared by more than one data collection. If yes,
    a deep copy of the object is made and the original object in the data collection is replaced with the copy. Now we can be confident that the copied data object is exclusively owned by the data collection and it's safe to modify it without risking side effects:

    .. literalinclude:: ../example_snippets/data_collection.py
           :lines: 37-44
    
    See also the :py:class:`~ovito.data.PipelineFlowState` class for more information on this topic.

    """

    @staticmethod
    def registerDataCollectionType(subclass):
        # Make the class a virtual subclass of DataCollection.
        DataCollection.register(subclass)

        # Unsuccessful attribute accesses on instances of the registered class 
        # will be forwarded to the DataCollection class.
        setattr(subclass, "__getattr__", lambda self,key: getattr(DataCollection, key).__get__(self, type(self)))

    @property
    def objects(self):
        """
        The list of data objects that make up the data collection. Data objects are instances of :py:class:`DataObject`-derived
        classes, for example :py:class:`ParticleProperty`, :py:class:`Bonds` or :py:class:`SimulationCell`.

        You can add or remove objects from the :py:attr:`!objects` list to insert them or remove them from the :py:class:`!DataCollection`. 
        However, it is your responsibility to ensure that the data objects are all in a consistent state. For example,
        all :py:class:`ParticleProperty` objects in a data collection must have the same lengths at all times, because
        the length implicitly specifies the number of particles. The order in which data objects are stored in the data collection
        does not matter.

        Note that the :py:class:`!DataCollection` class also provides convenience views of the data objects contained in the :py:attr:`!objects`
        list: For example, the :py:attr:`.particles` dictionary lists all :py:class:`ParticleProperty` instances in the 
        data collection by name and the :py:attr:`.bonds` does the same for all :py:class:`BondProperty` instances.
        Since these dictionaries are views, they always reflect the current contents of the master :py:attr:`!objects` list.
        """
        raise RuntimeError("This method should be overwritten by concrete implementations of the DataCollection interface.")

    # Implementation of the DataCollection.attributes field.
    @property
    def attributes(self):
        """
        A dictionary of key-value pairs that represent global tokens of information which are not associated with
        any specific data object in the data collection. 
        
        An *attribute* is a value of type ``int``, ``float``, or ``str`` with a unique identifier name such 
        as ``"Timestep"`` or ``"ConstructSurfaceMesh.surface_area"``. The attribute name serves as keys for the :py:attr:`!attributes` dictionary of the data collection.
        Attributes are dynamically generated by modifiers in a data pipeline or by a data source as explained in the following.
        
        **Attributes loaded from input files**

        The ``Timestep`` attribute is loaded from LAMMPS dump files and other simulation file formats
        that store the simulation timestep. Such input attributes can be retrieved from 
        the :py:attr:`!.attributes` dictionary of a pipeline's :py:attr:`~ovito.pipeline.FileSource`::

            >>> pipeline = import_file('snapshot_140000.dump')
            >>> pipeline.source.attributes['Timestep']
            140000
            
        Other attributes read from an input file are, for example, the key-value pairs found in the header line of *extended XYZ* files.
        
        **Dynamically computed attributes**
        
        Analysis modifiers like the :py:class:`~ovito.modifiers.CommonNeighborAnalysisModifier` or
        the :py:class:`~ovito.modifiers.ClusterAnalysisModifier` output scalar computation results
        as attributes. The reference documentation of each modifier type lists the attributes it produces.
        
        For example, the number of clusters identified by the :py:class:`~ovito.modifiers.ClusterAnalysisModifier`
        can be queried as follows::
        
            pipeline.modifiers.append(ClusterAnalysisModifier(cutoff = 3.1))
            data = pipeline.compute()
            nclusters = data.attributes["ClusterAnalysis.cluster_count"]
            
        **Exporting attributes to a text file**
        
        The :py:func:`ovito.io.export_file` function supports writing attribute values to a text
        file, possibly as functions of time::
        
            export_file(pipeline, "data.txt", "txt", 
                columns = ["Timestep", "ClusterAnalysis.cluster_count"], 
                multiple_frames = True)
                
        **User-defined attributes**
        
        The :py:class:`~ovito.modifiers.PythonScriptModifier` allows you to generate your own
        attributes that are dynamically computed (typically on the basis of some other input information):
        
        .. literalinclude:: ../example_snippets/python_modifier_generate_attribute.py
           :lines: 6-

        The :py:class:`~ovito.modifiers.CommonNeighborAnalysisModifier` used in the example above generates
        the attribute ``CommonNeighborAnalysis.counts.FCC`` to report the number of atoms that 
        form an FCC lattice. To compute the fraction of FCC atoms from that, we need to divide by the total number of 
        atoms in the system. To this end, we insert a :py:class:`~ovito.modifiers.PythonScriptModifier` 
        into the pipeline behind the :py:class:`~ovito.modifiers.CommonNeighborAnalysisModifier`.
        Our custom modifier function generates a new attribute named ``fcc_fraction``. Finally, 
        the value of the user-defined attribute can be queried from the pipeline or exported to 
        a text file using the :py:func:`~ovito.io.export_file` function as described above.
        """
        
        # Helper class used to implement the DataCollection.attributes field.
        class _AttributesView(collections.MutableMapping):
            
            def __init__(self, data_collection):
                """ Constructor that stores away a back-pointer to the owning DataCollection instance. """
                self._owner = data_collection
                
            def __len__(self):
                return len(self._owner.attribute_names)
            
            def __getitem__(self, key):
                v = self._owner.get_attribute(key)
                if v is not None:
                    return v
                raise KeyError("Attribute with the name '%s' not present in data collection." % key)

            def __setitem__(self, key, value):
                self._owner.set_attribute(key, value)

            def __delitem__(self, key):
                v = self._owner.get_attribute(key)
                if v is None:
                    raise KeyError("Attribute with the name '%s' not present in data collection." % key)
                self._owner.set_attribute(key, None)

            def __iter__(self):
                for aname in self._owner.attribute_names:
                    yield aname

            def __repr__(self):
                return repr(dict(self))
        
        return _AttributesView(self)

    def copy_if_needed(self, obj, deepcopy=False):
        """
        Makes a copy of a data object from this data collection if the object is not exclusively 
        owned by the data collection but shared with other collections. After the method returns,
        the data object is exclusively owned by the collection and it becomes safe to modify the object without
        causing unwanted side effects.

        Typically, this method is used in custom modifier functions (see :py:class:`~ovito.modifiers.PythonScriptModifier`) that
        participate in OVITO's data pipeline system. A modifier function receives an input collection of
        data objects from the system. However, modifying these input
        objects in place is not allowed, because they are owned by the pipeline and modifying them would 
        lead do unexpected side effects.
        This is where this method comes into play: It makes a copy of a given data object and replaces
        the original in the data collection with the copy. The caller can now safely modify this copy in place,
        because no other data collection can possibly be referring to it.

        The :py:meth:`!copy_if_needed` method first checks if *obj*, which must be a data object from this data collection, is
        shared with some other data collection. If yes, it creates an exact copy of *obj* and replaces the original
        in this data collection with the copy. Otherwise it leaves the object as is, because it is already exclusively owned
        by this data collection. 

        :param DataObject obj: The object from this data collection to be copied if needed.
        :return: An exact copy of *obj* if it was shared with some other data collection. Otherwise the original object is returned.
        """
        assert(isinstance(obj, DataObject))
        # The object to be modified must be in this data collection.
        if obj not in self.objects:
            raise ValueError("DataCollection.copy_if_needed() must be called with an object that is part of the data collection.")
        if obj.num_strong_references <= 1:
            return obj
        idx = self.objects.index(obj)
        clone = CloneHelper().clone(obj, deepcopy)
        self.objects[idx] = clone
        assert(clone.num_strong_references == 1)
        return clone

    def find(self, object_type):
        """
        Looks up the first data object from this collection of the given class type.

        :param object_type: The :py:class:`DataObject` subclass that should be looked up.
        :return: The first instance of the given class or its subclasses from the :py:attr:`.objects` list; or ``None`` if there is no instance.

        Method implementation::

            def find(self, object_type):
                for o in self.objects:
                    if isinstance(o, object_type): return o
                return None
        """
        if not issubclass(object_type, DataObject):
            raise ValueError("Not a subclass of ovito.data.DataObject: {}".format(object_type))
        for obj in self.objects:
            if isinstance(obj, object_type):
                return obj
        return None

    def expect(self, object_type):
        """
        Looks up the first data object in this collection of the given class type.
        Raises a ``KeyError`` if there is no instance matching the type. Use :py:meth:`.find` instead
        to test if the data collection contains the given type of data object.

        :param object_type: The :py:class:`DataObject` subclass specifying the type of object to find.
        :return: The first instance of the given class or its subclasses from the :py:attr:`.objects` list.
        """
        o = self.find(object_type)
        if o is None: raise KeyError('Data collection does not contain a {}'.format(object_type))
        return o

    def find_all(self, object_type):
        """
        Looks up all data objects from this collection of the given class type.

        :param object_type: The :py:class:`DataObject` subclass that should be looked up.
        :return: A Python list containing all instances of the given class or its subclasses from the :py:attr:`.objects` list.

        Method implementation::

            def find_all(self, object_type):
                return [o for o in self.objects if isinstance(o, object_type)]
        """
        if not issubclass(object_type, DataObject):
            raise ValueError("Not a subclass of ovito.data.DataObject: {}".format(object_type))
        return [obj for obj in self.objects if isinstance(obj, object_type)]

    def add(self, obj):
        # This method has been deprecated and is here only for backward compatibility with OVITO 2.9.0.
        # Use DataCollection.objects.append() instead.
        if not obj in self.objects:
            self.objects.append(obj)

    def remove(self, obj):
        # This method has been deprecated and is here only for backward compatibility with OVITO 2.9.0.
        # Use del DataCollection.objects[] instead.
        index = self.objects.index(obj)
        if index >= 0:
            del self.objects[index]

    def replace(self, oldobj, newobj):
        # This method has been deprecated and is here only for backward compatibility with OVITO 2.9.0.
        index = self.objects.index(oldobj)
        if index >= 0:
            self.objects[index] = newobj
