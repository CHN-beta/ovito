import abc
try:
    # Python 3.x
    import collections.abc as collections
except ImportError:
    # Python 2.x
    import collections

from ..plugins.PyScript import DataObject, CloneHelper, DataCollection, AttributeDataObject

# Implementation of the DataCollection.attributes field.
def _DataCollection_attributes(self):
    """
    This field contains a dictionary view with all the *global attributes* currently associated with this data collection.
    Global attributes are simple key-value pairs that represent small tokens of information.
    Attribute value typically have simple data types such as ``int``, ``float`` or ``str``. Every attribute has a unique identifier such 
    as ``"Timestep"`` or ``"ConstructSurfaceMesh.surface_area"``. The identifier serves as key for the :py:attr:`!attributes` dictionary.
    Attributes are dynamically generated by certain modifiers in a data pipeline or by the data source.
    For example, if the input simulation file contains timestep information, the timestep number is made available by the :py:attr:`~ovito.pipeline.FileSource` as the  
    ``Timestep`` attribute. It can be retrieved from pipeline's output data collection:

        >>> pipeline = import_file('snapshot_140000.dump')
        >>> pipeline.compute().attributes['Timestep']
        140000

    Some modifiers report their computation results by storing it as a new attribute in the data collection. See each modifier's
    reference documentation for the list of attributes it will generate. For example, the number of clusters identified by the 
    :py:class:`~ovito.modifiers.ClusterAnalysisModifier` is available in the pipeline output as an attribute named
    ``ClusterAnalysis.cluster_count``::
    
        pipeline.modifiers.append(ClusterAnalysisModifier(cutoff = 3.1))
        data = pipeline.compute()
        nclusters = data.attributes["ClusterAnalysis.cluster_count"]
        
    The :py:func:`ovito.io.export_file` function can be used to write attributes to a text file, possibly as functions of time::
    
        export_file(pipeline, "data.txt", "txt/attr", 
            columns = ["Timestep", "ClusterAnalysis.cluster_count"], 
            multiple_frames = True)
            
    If you are writing your own modifier function, you can add dynamically computed attributes to a data collection. 
    In the following example, the :py:class:`~ovito.modifiers.CommonNeighborAnalysisModifier` first added to the
    pipeline generates the ``CommonNeighborAnalysis.counts.FCC`` attribute to report the number of atoms that 
    form an FCC lattice. To compute the fraction of FCC atoms from that, we need to divide the FCC count by the total number of 
    atoms in the system. To this end, we append a user-defined modifier function 
    to the pipeline, which computes the fraction and outputs it as a new attribute named ``fcc_fraction``. 
    
    .. literalinclude:: ../example_snippets/python_modifier_generate_attribute.py
        :lines: 6-

    """
        
    # Helper class used to implement the DataCollection.attributes field.
    class _AttributesView(collections.MutableMapping):
        
        def __init__(self, data_collection):
            """ Constructor that stores away a back-pointer to the owning DataCollection instance. """
            self._collection = data_collection
            
        def __len__(self):
            count = 0
            for obj in self._collection.objects:
                if isinstance(obj, AttributeDataObject):
                    count += 1
            return count
        
        def __getitem__(self, key):
            for obj in self._collection.objects:
                if isinstance(obj, AttributeDataObject) and obj.identifier == key:
                    return obj.value
            raise KeyError("Attribute '%s' does not exist in data collection." % str(key))

        def __setitem__(self, key, value):
            for obj in self._collection.objects:
                if isinstance(obj, AttributeDataObject) and obj.identifier == key:
                    if not value is None:
                        self._collection.make_mutable(obj).value = value
                    else:
                        del self._collection.objects[obj]
                    return
            if not value is None:
                attr =  AttributeDataObject(identifier = key, value = value)
                self._collection.objects.append(attr)

        def __delitem__(self, key):
            """ Removes a global attribute from the data collection. """
            for obj in self._collection.objects:
                if isinstance(obj, AttributeDataObject) and obj.identifier == key:
                    del self._collection.objects[obj]
                    return
            raise KeyError("Attribute '%s' does not exist in data collection." % str(key))

        def __iter__(self):
            """ Returns an iterator over the names of all global attributes. """
            for obj in self._collection.objects:
                if isinstance(obj, AttributeDataObject):
                    yield obj.identifier

        def __repr__(self):
            return repr(dict(self))
    
    return _AttributesView(self)
DataCollection.attributes = property(_DataCollection_attributes)

# Implementation of the DataCollection.find() method.
def _DataCollection_find(self, data_obj_class):
    # Internal method used for looking up a certain type of DataObject in a DataCollection.
    assert(issubclass(data_obj_class, DataObject))
    for obj in self.objects:
        if isinstance(obj, data_obj_class):
            return obj
    return None
DataCollection.find = _DataCollection_find

# This method has been deprecated and is here only for backward compatibility with OVITO 2.9.0.
# Use DataCollection.objects.append() instead.
def _DataCollection_add(self, obj):
    if not obj in self.objects:
        self.objects.append(obj)
DataCollection.add = _DataCollection_add

# This method has been deprecated and is here only for backward compatibility with OVITO 2.9.0.
# Use del DataCollection.objects[] instead.
def _DataCollection_remove(self, obj):
    index = self.objects.index(obj)
    if index >= 0:
        del self.objects[index]
DataCollection.remove = _DataCollection_remove

# This method has been deprecated and is here only for backward compatibility with OVITO 2.9.0.
def _DataCollection_replace(self, oldobj, newobj):
    index = self.objects.index(oldobj)
    if index >= 0:
        self.objects[index] = newobj
DataCollection.replace = _DataCollection_replace

# Only here for backward compatibility with OVITO 2.9.0:
DataCollection.copy_if_needed = lambda self, obj: self.make_mutable(obj)
