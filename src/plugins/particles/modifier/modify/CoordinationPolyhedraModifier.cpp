///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (2017) Alexander Stukowski
//
//  This file is part of OVITO (Open Visualization Tool).
//
//  OVITO is free software; you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation; either version 2 of the License, or
//  (at your option) any later version.
//
//  OVITO is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
///////////////////////////////////////////////////////////////////////////////

#include <plugins/particles/Particles.h>
#include <plugins/mesh/surface/SurfaceMesh.h>
#include <plugins/mesh/surface/SurfaceMeshVis.h>
#include <plugins/particles/objects/ParticlesObject.h>
#include <plugins/particles/objects/ParticleBondMap.h>
#include <core/dataset/DataSet.h>
#include <plugins/stdobj/simcell/SimulationCellObject.h>
#include <core/dataset/pipeline/ModifierApplication.h>
#include "CoordinationPolyhedraModifier.h"

namespace Ovito { namespace Particles { OVITO_BEGIN_INLINE_NAMESPACE(Modifiers) OVITO_BEGIN_INLINE_NAMESPACE(Modify)

IMPLEMENT_OVITO_CLASS(CoordinationPolyhedraModifier);
DEFINE_REFERENCE_FIELD(CoordinationPolyhedraModifier, surfaceMeshVis);

/******************************************************************************
* Constructs the modifier object.
******************************************************************************/
CoordinationPolyhedraModifier::CoordinationPolyhedraModifier(DataSet* dataset) : AsynchronousModifier(dataset)
{
	// Create the vis element for rendering the polyhedra generated by the modifier.
	setSurfaceMeshVis(new SurfaceMeshVis(dataset));
	surfaceMeshVis()->setShowCap(false);
	surfaceMeshVis()->setSmoothShading(false);
	surfaceMeshVis()->setSurfaceTransparency(FloatType(0.25));
	surfaceMeshVis()->setObjectTitle(tr("Polyhedra"));
}

/******************************************************************************
* Asks the modifier whether it can be applied to the given input data.
******************************************************************************/
bool CoordinationPolyhedraModifier::OOMetaClass::isApplicableTo(const DataCollection& input) const
{
	if(const ParticlesObject* particles = input.getObject<ParticlesObject>()) {
		return particles->bonds() != nullptr;
	}
	return false;
}

/******************************************************************************
* Creates and initializes a computation engine that will compute the
* modifier's results.
******************************************************************************/
Future<AsynchronousModifier::ComputeEnginePtr> CoordinationPolyhedraModifier::createEngine(TimePoint time, ModifierApplication* modApp, const PipelineFlowState& input)
{
	// Get modifier input.
	const ParticlesObject* particles = input.expectObject<ParticlesObject>();
	const PropertyObject* posProperty = particles->expectProperty(ParticlesObject::PositionProperty);
	const PropertyObject* typeProperty = particles->getProperty(ParticlesObject::TypeProperty);
	const PropertyObject* selectionProperty = particles->getProperty(ParticlesObject::SelectionProperty);
	const PropertyObject* topologyProperty = particles->expectBondsTopology();
	const PropertyObject* bondPeriodicImagesProperty = particles->bonds()->getProperty(BondsObject::PeriodicImageProperty);
	const SimulationCellObject* simCell = input.expectObject<SimulationCellObject>();

	if(!selectionProperty)
		throwException(tr("Please select particles first for which coordination polyhedra should be generated."));

	// Create engine object. Pass all relevant modifier parameters to the engine as well as the input data.
	return std::make_shared<ComputePolyhedraEngine>(
			posProperty->storage(),
			selectionProperty->storage(),
			typeProperty ? typeProperty->storage() : nullptr,
			topologyProperty->storage(),
			bondPeriodicImagesProperty ? bondPeriodicImagesProperty->storage() : nullptr,
			simCell->data());
}

/******************************************************************************
* Performs the actual analysis. This method is executed in a worker thread.
******************************************************************************/
void CoordinationPolyhedraModifier::ComputePolyhedraEngine::perform()
{
	task()->setProgressText(tr("Generating coordination polyhedra"));

	// Determine number of selected particles.
	size_t npoly = std::count_if(_selection->constDataInt(), _selection->constDataInt() + _selection->size(), [](int s) { return s != 0; });
	task()->setProgressMaximum(npoly);

	std::vector<Point3> bondVectors;
	ParticleBondMap bondMap(_bondTopology, _bondPeriodicImages);

	for(size_t i = 0; i < _positions->size(); i++) {
		if(_selection->getInt(i) == 0) continue;

		// Collect the bonds that are part of the coordination polyhedron.
		const Point3& p1 = _positions->getPoint3(i);
		for(Bond bond : bondMap.bondsOfParticle(i)) {
			if(bond.index2 < _positions->size()) {
				Vector3 delta = _positions->getPoint3(bond.index2) - p1;
				if(bond.pbcShift.x()) delta += cell().matrix().column(0) * (FloatType)bond.pbcShift.x();
				if(bond.pbcShift.y()) delta += cell().matrix().column(1) * (FloatType)bond.pbcShift.y();
				if(bond.pbcShift.z()) delta += cell().matrix().column(2) * (FloatType)bond.pbcShift.z();
				bondVectors.push_back(p1 + delta);
			}
		}

		// Construct the polyhedron (i.e. convex hull) from the bond vectors.
		constructConvexHull(bondVectors);
		bondVectors.clear();

		if(!task()->incrementProgressValue())
			return;
	}
}

/******************************************************************************
* Constructs the convex hull from a set of points and adds the resulting
* polyhedron to the mesh.
******************************************************************************/
void CoordinationPolyhedraModifier::ComputePolyhedraEngine::constructConvexHull(std::vector<Point3>& vecs)
{
	if(vecs.size() < 4) return;	// Convex hull requires at least 4 input points.

	// Keep track of how many faces and vertices we started with.
	// We won't touch the existing mesh faces and vertices.
	auto originalFaceCount = mesh().faceCount();
	auto originalVertexCount = mesh().vertexCount();

	// Determine which points should form the initial tetrahedron.
	// Make sure they are not co-planar.
	size_t tetrahedraCorners[4];
	tetrahedraCorners[0] = 0;
	size_t n = 1;
	Matrix3 m;
	for(size_t i = 1; i < vecs.size(); i++) {
		if(n == 1) {
			m.column(0) = vecs[i] - vecs[0];
			tetrahedraCorners[1] = i;
			if(!m.column(0).isZero()) n = 2;
		}
		else if(n == 2) {
			m.column(1) = vecs[i] - vecs[0];
			tetrahedraCorners[2] = i;
			if(!m.column(0).cross(m.column(1)).isZero()) n = 3;
		}
		else if(n == 3) {
			m.column(2) = vecs[i] - vecs[0];
			FloatType det = m.determinant();
			if(std::abs(det) > FLOATTYPE_EPSILON) {
				tetrahedraCorners[3] = i;
				if(det < 0) std::swap(tetrahedraCorners[0], tetrahedraCorners[1]);
				n = 4;
				break;
			}
		}
	}
	if(n != 4) return;

	// Create the initial tetrahedron.
	HalfEdgeMesh::vertex_index tetverts[4];
	for(size_t i = 0; i < 4; i++) {
        tetverts[i] = mesh().createVertex(vecs[tetrahedraCorners[i]]);
	}
	mesh().createFace({tetverts[0], tetverts[1], tetverts[3]});
	mesh().createFace({tetverts[2], tetverts[0], tetverts[3]});
	mesh().createFace({tetverts[0], tetverts[2], tetverts[1]});
	mesh().createFace({tetverts[1], tetverts[2], tetverts[3]});
	// Connect opposite half-edges to link the four faces together.
	for(size_t i = 0; i < 4; i++)
		mesh().topology()->connectOppositeHalfedges(tetverts[i]);

	// Remove 4 points of initial tetrahedron from input list.
	for(size_t i = 1; i <= 4; i++)
		vecs[tetrahedraCorners[4-i]] = vecs[vecs.size()-i];
	vecs.erase(vecs.end() - 4, vecs.end());

	// Simplified Quick-hull algorithm.
	for(;;) {
		// Find the point on the positive side of a face and furthest away from it.
		// Also remove points from list which are on the negative side of all faces.
		auto furthestPoint = vecs.rend();
		FloatType furthestPointDistance = 0;
		size_t remainingPointCount = vecs.size();
		for(auto p = vecs.rbegin(); p != vecs.rend(); ++p) {
			bool insideHull = true;
			for(auto faceIndex = originalFaceCount; faceIndex < mesh().faceCount(); faceIndex++) {
				auto v0 = mesh().firstFaceVertex(faceIndex);
				auto v1 = mesh().secondFaceVertex(faceIndex);
				auto v2 = mesh().thirdFaceVertex(faceIndex);
				Plane3 plane(mesh().vertexPosition(v0), mesh().vertexPosition(v1), mesh().vertexPosition(v2), true);
				FloatType signedDistance = plane.pointDistance(*p);
				if(signedDistance > FLOATTYPE_EPSILON) {
					insideHull = false;
					if(signedDistance > furthestPointDistance) {
						furthestPointDistance = signedDistance;
						furthestPoint = p;
					}
				}
			}
			// When point is inside the hull, remove it from the input list.
			if(insideHull) {
				remainingPointCount--;
				*p = vecs[remainingPointCount];
			}
		}
		if(!remainingPointCount) break;
		OVITO_ASSERT(furthestPointDistance > 0 && furthestPoint != vecs.rend());

		// Kill all faces of the polyhedron that can be seen from the selected point.
		for(auto face = originalFaceCount; face < mesh().faceCount(); face++) {
			auto v0 = mesh().firstFaceVertex(face);
			auto v1 = mesh().secondFaceVertex(face);
			auto v2 = mesh().thirdFaceVertex(face);
			Plane3 plane(mesh().vertexPosition(v0), mesh().vertexPosition(v1), mesh().vertexPosition(v2), true);
			if(plane.pointDistance(*furthestPoint) > FLOATTYPE_EPSILON) {
				mesh().deleteFace(face);
				face--;
			}
		}

		// Find an edge that borders the newly created hole in the mesh.
		HalfEdgeMesh::edge_index firstBorderEdge = HalfEdgeMesh::InvalidIndex;
		for(auto face = originalFaceCount; face < mesh().faceCount() && firstBorderEdge == HalfEdgeMesh::InvalidIndex; face++) {
			HalfEdgeMesh::edge_index e = mesh().firstFaceEdge(face);
			OVITO_ASSERT(e != HalfEdgeMesh::InvalidIndex);
			do {
				if(!mesh().hasOppositeEdge(e)) {
					firstBorderEdge = e;
					break;
				}
				e = mesh().nextFaceEdge(e);
			}
			while(e != mesh().firstFaceEdge(face));
		}
		OVITO_ASSERT(firstBorderEdge != HalfEdgeMesh::InvalidIndex); // If this assert fails, then there was no hole in the mesh.

		// Create new faces that connects the edges at the horizon (i.e. the border of the hole) with
		// the selected vertex.
		HalfEdgeMesh::vertex_index vertex = mesh().createVertex(*furthestPoint);
		HalfEdgeMesh::edge_index borderEdge = firstBorderEdge;
		HalfEdgeMesh::face_index previousFace = HalfEdgeMesh::InvalidIndex;
		HalfEdgeMesh::face_index firstFace = HalfEdgeMesh::InvalidIndex;
		HalfEdgeMesh::face_index newFace;
		do {
			newFace = mesh().createFace({ mesh().vertex2(borderEdge), mesh().vertex1(borderEdge), vertex });
			mesh().linkOppositeEdges(mesh().firstFaceEdge(newFace), borderEdge);
			if(borderEdge == firstBorderEdge)
				firstFace = newFace;
			else
				mesh().linkOppositeEdges(mesh().secondFaceEdge(newFace), mesh().prevFaceEdge(mesh().firstFaceEdge(previousFace)));
			previousFace = newFace;
			// Proceed to next edge along the hole's border.
			for(;;) {
				borderEdge = mesh().nextFaceEdge(borderEdge);
				if(!mesh().hasOppositeEdge(borderEdge) || borderEdge == firstBorderEdge)
					break;
				borderEdge = mesh().oppositeEdge(borderEdge);
			}
		}
		while(borderEdge != firstBorderEdge);
		OVITO_ASSERT(firstFace != newFace);
		mesh().linkOppositeEdges(mesh().secondFaceEdge(firstFace), mesh().prevFaceEdge(mesh().firstFaceEdge(newFace)));

		// Remove selected point from the input list as well.
		remainingPointCount--;
		*furthestPoint = vecs[remainingPointCount];
		vecs.resize(remainingPointCount);
	}

	// Delete interior vertices from the mesh that are no longer attached to any of the faces.
	for(auto vertex = originalVertexCount; vertex < mesh().vertexCount(); vertex++) {
		if(mesh().vertexEdgeCount(vertex) == 0) {
			// Delete the vertex from the mesh topology.
			mesh().deleteVertex(vertex);
			// Adjust index to point to next vertex in the mesh after loop incrementation.
			vertex--;
		}
	}
}

/******************************************************************************
* Injects the computed results of the engine into the data pipeline.
******************************************************************************/
void CoordinationPolyhedraModifier::ComputePolyhedraEngine::emitResults(TimePoint time, ModifierApplication* modApp, PipelineFlowState& state)
{
	CoordinationPolyhedraModifier* modifier = static_object_cast<CoordinationPolyhedraModifier>(modApp->modifier());

	// Create the output data object.
	SurfaceMesh* meshObj = state.createObject<SurfaceMesh>(QStringLiteral("coord-polyhedra"), modApp, tr("Coordination polyhedra"));
	mesh().transferTo(meshObj);
	meshObj->setDomain(state.getObject<SimulationCellObject>());
	meshObj->setVisElement(modifier->surfaceMeshVis());
}

OVITO_END_INLINE_NAMESPACE
OVITO_END_INLINE_NAMESPACE
}	// End of namespace
}	// End of namespace
