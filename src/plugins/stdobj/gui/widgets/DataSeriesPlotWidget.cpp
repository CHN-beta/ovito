///////////////////////////////////////////////////////////////////////////////
// 
//  Copyright (2018) Alexander Stukowski
//
//  This file is part of OVITO (Open Visualization Tool).
//
//  OVITO is free software; you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation; either version 2 of the License, or
//  (at your option) any later version.
//
//  OVITO is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
///////////////////////////////////////////////////////////////////////////////

#include <plugins/stdobj/gui/StdObjGui.h>
#include "DataSeriesPlotWidget.h"

#include <qwt/qwt_plot.h>
#include <qwt/qwt_plot_curve.h>
#include <qwt/qwt_plot_grid.h>
#include <qwt/qwt_plot_legenditem.h>

namespace Ovito { namespace StdObj {

/******************************************************************************
* Constructor.
******************************************************************************/
DataSeriesPlotWidget::DataSeriesPlotWidget(QWidget* parent) : QwtPlot(parent)
{
	setCanvasBackground(Qt::white);

	// Show a grid in the background of the plot.
	QwtPlotGrid* plotGrid = new QwtPlotGrid();
	plotGrid->setPen(Qt::gray, 0, Qt::DotLine);
	plotGrid->attach(this);

	// Listen for events from the data series.
	connect(&_series, &RefTargetListener<DataSeriesObject>::notificationEvent, this, &DataSeriesPlotWidget::onSeriesNotificationEvent);
}

/******************************************************************************
* This handles reference events generated by the data series object.
******************************************************************************/
void DataSeriesPlotWidget::onSeriesNotificationEvent(const ReferenceEvent& event)
{
	if(event.type() == ReferenceEvent::TargetChanged) {
		updateDataPlot();
	}
}

/******************************************************************************
* Regenerates the plot. 
* This function is called whenever a new data series has been loaded into 
* widget or if the current series data changes.
******************************************************************************/
void DataSeriesPlotWidget::updateDataPlot()
{
	static const Qt::GlobalColor curveColors[] = {
		Qt::black, Qt::red, Qt::blue, Qt::green,
		Qt::cyan, Qt::magenta, Qt::gray, Qt::darkRed, 
		Qt::darkGreen, Qt::darkBlue, Qt::darkCyan, Qt::darkMagenta,
		Qt::darkYellow, Qt::darkGray
	};
	
	setAxisTitle(QwtPlot::xBottom, QString{});
	setAxisTitle(QwtPlot::yLeft, QString{});
	if(series() && series()->y()) {
		const auto& x = series()->x();
		const auto& y = series()->y();
		while(_curves.size() < y->componentCount()) {
			QwtPlotCurve* curve = new QwtPlotCurve();
			curve->setRenderHint(QwtPlotItem::RenderAntialiased, true);
			curve->setPen(QPen(curveColors[_curves.size() % (sizeof(curveColors)/sizeof(curveColors[0]))], 1));
			curve->attach(this);
			_curves.push_back(curve);
		}
		while(_curves.size() > y->componentCount()) {
			delete _curves.back();
			_curves.pop_back();
		}
		if(_curves.size() == 1 && y->componentNames().empty()) {
			_curves[0]->setBrush(QColor(255, 160, 100));
		}
		else {
			for(QwtPlotCurve* curve : _curves)
				curve->setBrush({});
		}
		if(y->componentNames().empty()) {
			if(_legend) {
				delete _legend;
				_legend = nullptr;
			}
		}
		else {
			if(!_legend) {
				_legend = new QwtPlotLegendItem();
				_legend->setAlignment(Qt::AlignRight | Qt::AlignTop);
				_legend->attach(this);
			}
		}

		QVector<double> xcoords(y->size());
		if(!x || x->size() != xcoords.size() || !x->copyTo(xcoords.begin())) {
			if(series()->intervalStart() < series()->intervalEnd() && y->size() != 0) {
				FloatType binSize = (series()->intervalEnd() - series()->intervalStart()) / y->size();
				double xc = series()->intervalStart() + binSize / 2;
				for(auto& v : xcoords) {
					v = xc;
					xc += binSize;
				}
			}
			else {
				std::iota(xcoords.begin(), xcoords.end(), 0);
			}
		}

		QVector<double> ycoords(y->size());
		for(size_t cmpnt = 0; cmpnt < y->componentCount(); cmpnt++) {
			if(!y->copyTo(ycoords.begin(), cmpnt)) {
				std::fill(ycoords.begin(), ycoords.end(), 0.0);
			}
			_curves[cmpnt]->setSamples(xcoords, ycoords);
			if(cmpnt < y->componentNames().size())
				_curves[cmpnt]->setTitle(y->componentNames()[cmpnt]);
		}

		setAxisTitle(QwtPlot::xBottom, series()->getAxisLabelXAny());
		setAxisTitle(QwtPlot::yLeft, series()->getAxisLabelYAny());
	}
	else {
		for(QwtPlotCurve* curve : _curves)
			delete curve;
		_curves.clear();
		delete _legend;
		_legend = nullptr;
	}

	replot();
}

}	// End of namespace
}	// End of namespace
