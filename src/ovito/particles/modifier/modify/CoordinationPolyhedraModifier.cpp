////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright 2021 OVITO GmbH, Germany
//
//  This file is part of OVITO (Open Visualization Tool).
//
//  OVITO is free software; you can redistribute it and/or modify it either under the
//  terms of the GNU General Public License version 3 as published by the Free Software
//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.
//  If you do not alter this notice, a recipient may use your version of this
//  file under either the GPL or the MIT License.
//
//  You should have received a copy of the GPL along with this program in a
//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along
//  with this program in a file LICENSE.MIT.txt
//
//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,
//  either express or implied. See the GPL or the MIT License for the specific language
//  governing rights and limitations.
//
////////////////////////////////////////////////////////////////////////////////////////

#include <ovito/particles/Particles.h>
#include <ovito/mesh/surface/SurfaceMesh.h>
#include <ovito/mesh/surface/SurfaceMeshVis.h>
#include <ovito/stdobj/simcell/SimulationCellObject.h>
#include <ovito/stdobj/properties/PropertyAccess.h>
#include <ovito/particles/objects/ParticlesObject.h>
#include <ovito/particles/objects/ParticleBondMap.h>
#include <ovito/core/dataset/DataSet.h>
#include <ovito/core/dataset/pipeline/ModifierApplication.h>
#include "CoordinationPolyhedraModifier.h"

namespace Ovito { namespace Particles {

IMPLEMENT_OVITO_CLASS(CoordinationPolyhedraModifier);
DEFINE_REFERENCE_FIELD(CoordinationPolyhedraModifier, surfaceMeshVis);
DEFINE_PROPERTY_FIELD(CoordinationPolyhedraModifier, transferParticleProperties);
SET_PROPERTY_FIELD_LABEL(CoordinationPolyhedraModifier, transferParticleProperties, "Transfer particle properties to mesh");

/******************************************************************************
* Constructs the modifier object.
******************************************************************************/
CoordinationPolyhedraModifier::CoordinationPolyhedraModifier(DataSet* dataset) : AsynchronousModifier(dataset),
	_transferParticleProperties(true)
{
}

/******************************************************************************
* Initializes the object's parameter fields with default values and loads 
* user-defined default values from the application's settings store (GUI only).
******************************************************************************/
void CoordinationPolyhedraModifier::initializeObject(ExecutionContext executionContext)
{
	AsynchronousModifier::initializeObject(executionContext);

	// Create the vis element for rendering the polyhedra generated by the modifier.
	if(!surfaceMeshVis()) {
		setSurfaceMeshVis(OORef<SurfaceMeshVis>::create(dataset(), executionContext));
		surfaceMeshVis()->setShowCap(false);
		surfaceMeshVis()->setSmoothShading(false);
		surfaceMeshVis()->setSurfaceTransparency(FloatType(0.25));
		surfaceMeshVis()->setObjectTitle(tr("Polyhedra"));
		if(executionContext == ExecutionContext::Interactive)
			surfaceMeshVis()->setHighlightEdges(true);
	}
}

/******************************************************************************
* Asks the modifier whether it can be applied to the given input data.
******************************************************************************/
bool CoordinationPolyhedraModifier::OOMetaClass::isApplicableTo(const DataCollection& input) const
{
	if(const ParticlesObject* particles = input.getObject<ParticlesObject>()) {
		return particles->bonds() != nullptr;
	}
	return false;
}

/******************************************************************************
* Creates and initializes a computation engine that will compute the
* modifier's results.
******************************************************************************/
Future<AsynchronousModifier::EnginePtr> CoordinationPolyhedraModifier::createEngine(const PipelineEvaluationRequest& request, ModifierApplication* modApp, const PipelineFlowState& input, ExecutionContext executionContext)
{
	// Get modifier input.
	const ParticlesObject* particles = input.expectObject<ParticlesObject>();
	particles->verifyIntegrity();
	const PropertyObject* posProperty = particles->expectProperty(ParticlesObject::PositionProperty);
	const PropertyObject* typeProperty = particles->getProperty(ParticlesObject::TypeProperty);
	const PropertyObject* identifierProperty = particles->getProperty(ParticlesObject::IdentifierProperty);
	const PropertyObject* selectionProperty = particles->getProperty(ParticlesObject::SelectionProperty);

	particles->expectBonds()->verifyIntegrity();
	const PropertyObject* topologyProperty = particles->expectBondsTopology();
	const PropertyObject* bondPeriodicImagesProperty = particles->bonds()->getProperty(BondsObject::PeriodicImageProperty);
	const SimulationCellObject* simCell = input.expectObject<SimulationCellObject>();

	if(!selectionProperty)
		throwException(tr("Please first select some particles, for which coordination polyhedra should be generated."));

	// Collect the set of particle properties that should be transferred over to the surface mesh vertices.
	std::vector<ConstPropertyPtr> particleProperties;
	if(transferParticleProperties()) {
		for(const PropertyObject* property : particles->properties()) {
			// Certain properties should never be transferred to the mesh vertices.
			if(property->type() == ParticlesObject::SelectionProperty) continue;
			if(property->type() == ParticlesObject::PositionProperty) continue;
			if(property->type() == ParticlesObject::IdentifierProperty) continue;
			if(property->type() == ParticlesObject::ColorProperty) continue;
			if(property->type() == ParticlesObject::VectorColorProperty) continue;
			if(property->type() == ParticlesObject::PeriodicImageProperty) continue;
			if(property->type() == ParticlesObject::TransparencyProperty) continue;
			particleProperties.push_back(property);
		}
	}

	// Create the output data object.
	DataOORef<SurfaceMesh> mesh = DataOORef<SurfaceMesh>::create(dataset(), executionContext, tr("Coordination polyhedra"));
	mesh->setIdentifier(input.generateUniqueIdentifier<SurfaceMesh>(QStringLiteral("coord-polyhedra")));
	mesh->setDataSource(modApp);
	mesh->setDomain(simCell);
	mesh->setVisElement(surfaceMeshVis());

	// Create engine object. Pass all relevant modifier parameters to the engine as well as the input data.
	return std::make_shared<ComputePolyhedraEngine>(
			modApp,
			executionContext, 
			dataset(),
			posProperty,
			selectionProperty,
			typeProperty,
			identifierProperty,
			topologyProperty,
			bondPeriodicImagesProperty,
			std::move(mesh),
			std::move(particleProperties));
}

/******************************************************************************
* Performs the actual analysis. This method is executed in a worker thread.
******************************************************************************/
void CoordinationPolyhedraModifier::ComputePolyhedraEngine::perform()
{
	setProgressText(tr("Generating coordination polyhedra"));

	// Create the "Region" face property.
	SurfaceMeshAccess mesh(_mesh);
	mesh.createFaceProperty(SurfaceMeshFaces::RegionProperty, false, executionContext());

	// Determine number of selected particles.
	ConstPropertyAccess<int> selectionArray(_selection);
	size_t npoly = boost::count_if(selectionArray, [](int s) { return s != 0; });
	setProgressMaximum(npoly);

	ParticleBondMap bondMap(_bondTopology, _bondPeriodicImages);

	ConstPropertyAccess<Point3> positionsArray(_positions);

	// Working variables.
	std::vector<Point3> neighborPositions;
	std::vector<size_t> neighborIndices;
	SurfaceMeshAccess::size_type oldVertexCount = 0;

	// After construction of the mesh, this array will contain for each 
	// mesh vertex the index of the particle it was created from.
	std::vector<size_t> vertexToParticleMap;

	// Iterate over all input particles.
	for(size_t i = 0; i < positionsArray.size(); i++) {
		// Construct corodination polyhedron only for selected particles.
		if(selectionArray[i] == 0) continue;

		// Collect the bonds that are part of the coordination polyhedron.
		const Point3& p1 = positionsArray[i];
		for(BondWithIndex bond : bondMap.bondsOfParticle(i)) {
			if(bond.index2 < _positions->size()) {
				Vector3 delta = positionsArray[bond.index2] - p1;
				if(bond.pbcShift.x()) delta += cell()->matrix().column(0) * (FloatType)bond.pbcShift.x();
				if(bond.pbcShift.y()) delta += cell()->matrix().column(1) * (FloatType)bond.pbcShift.y();
				if(bond.pbcShift.z()) delta += cell()->matrix().column(2) * (FloatType)bond.pbcShift.z();
				neighborPositions.push_back(p1 + delta);
				neighborIndices.push_back(bond.index2);
			}
		}

		// Include the central particle in the point list too.
		neighborPositions.push_back(p1);
		neighborIndices.push_back(i);

		// Construct the polyhedron (i.e. convex hull) from the point list.
		if(particleProperties().empty()) {
			// Note: We are moving the point list into the convex hull method to avoid an extra copy.
			mesh.constructConvexHull(std::move(neighborPositions));
		}
		else {
			// Note: We keep our own copy of the point list so that we can determine the insertion order afterwards.
			mesh.constructConvexHull(neighborPositions);

			// Find each input point among the newly added vertices of the mesh. 
			// This will help us later to transfer the particle properties to the corresponding mesh vertices. 
			for(const Point3& vpos : mesh.vertexPositions().advance_begin(oldVertexCount)) {
				auto idx = neighborIndices.cbegin();
				for(const Point3& p : neighborPositions) {
					OVITO_ASSERT(idx != neighborIndices.cend());
					if(vpos == p) {
						vertexToParticleMap.push_back(*idx);
						break;
					}
					++idx;
				}
			}
			OVITO_ASSERT(vertexToParticleMap.size() == mesh.vertexCount());
			oldVertexCount = mesh.vertexCount();
		}

		// Clear point list for next loop iteration.
		neighborPositions.clear();
		neighborIndices.clear();

		if(!incrementProgressValue())
			return;
	}

	// Transfer particle properties to the mesh vertices if requested.
	if(!particleProperties().empty()) {
		OVITO_ASSERT(vertexToParticleMap.size() == mesh.vertexCount());
		for(const ConstPropertyPtr& particleProperty : particleProperties()) {
			PropertyPtr vertexProperty;
			if(SurfaceMeshVertices::OOClass().isValidStandardPropertyId(particleProperty->type())) {
				// Input property is also a standard property for mesh vertices.
				vertexProperty = mesh.createVertexProperty(static_cast<SurfaceMeshVertices::Type>(particleProperty->type()), false, executionContext());
				OVITO_ASSERT(vertexProperty->dataType() == particleProperty->dataType());
				OVITO_ASSERT(vertexProperty->stride() == particleProperty->stride());
			}
			else if(SurfaceMeshVertices::OOClass().standardPropertyTypeId(particleProperty->name()) != 0) {
				// Input property name is that of a standard property for mesh vertices.
				// Must rename the property to avoid conflict, because user properties may not have a standard property name.
				QString newPropertyName = particleProperty->name() + tr("_particles");
				vertexProperty = mesh.createVertexProperty(newPropertyName, particleProperty->dataType(), particleProperty->componentCount(), particleProperty->stride(), false, particleProperty->componentNames());
			}
			else {
				// Input property is a user property for mesh vertices.
				vertexProperty = mesh.createVertexProperty(particleProperty->name(), particleProperty->dataType(), particleProperty->componentCount(), particleProperty->stride(), false, particleProperty->componentNames());
			}
			// Copy particle property values to mesh vertices using precomputed index mapping.
			particleProperty->mappedCopyTo(*vertexProperty, vertexToParticleMap);
		}
	}

	// Create the "Center particle" region property, which indicates the ID of the particle that is at the center of each coordination polyhedron.
	PropertyAccess<qlonglong> centerProperty = mesh.createRegionProperty(QStringLiteral("Center Particle"), PropertyObject::Int64, 1, 0, false);
	ConstPropertyAccess<qlonglong> particleIdentifiersArray(_particleIdentifiers);
	auto centerParticle = centerProperty.begin();
	for(size_t i = 0; i < positionsArray.size(); i++) {
		if(selectionArray[i] == 0) continue;
		if(particleIdentifiersArray)
			*centerParticle++ = particleIdentifiersArray[i];
		else
			*centerParticle++ = i;
	}
	OVITO_ASSERT(centerParticle == centerProperty.end());

	// Release data that is no longer needed.
	_positions.reset();
	_selection.reset();
	_particleTypes.reset();
	_particleIdentifiers.reset();
	_bondTopology.reset();
	_bondPeriodicImages.reset();
	_particleProperties.clear();
}

/******************************************************************************
* Injects the computed results of the engine into the data pipeline.
******************************************************************************/
void CoordinationPolyhedraModifier::ComputePolyhedraEngine::applyResults(TimePoint time, ModifierApplication* modApp, PipelineFlowState& state)
{
	// Output the constructed mesh to the pipeline.
	state.addObjectWithUniqueId<SurfaceMesh>(_mesh);
}

}	// End of namespace
}	// End of namespace
